# ПЗ-5 Славінський Костянтин ЦК-31
## Код із виконанням знаходиться у папці (src)
## Контрольні питання
1.Переваги та недоліки методів сортуванняСортування бульбашкою (Bubble Sort)
 - Переваги: Найпростіший для розуміння та реалізації алгоритм. Стійкий (не змінює порядок однакових елементів). Може виявити вже відсортований масив за один прохід (в оптимізованій версії).
 - Недоліки: Дуже повільний $O(n^2)$. Виконує дуже багато операцій обміну (swap), що затратно для процесора.
Сортування вибором (Selection Sort)
 - Переваги: Робить найменшу кількість обмінів елементів серед простих алгоритмів $O(n)$ записів у пам'ять). Проста реалізація. Добре працює, коли запис у пам'ять коштує набагато дорожче, ніж порівняння.
 - Недоліки: Зазвичай нестійкий (unstable). Час виконання не залежить від впорядкованості масиву (навіть для відсортованого масиву він все одно перевірятиме всі пари).
Сортування вставкою (Insertion Sort)
 - Переваги: Дуже ефективний на частково відсортованих масивах або масивах малого розміру (навіть швидший за складні алгоритми типу QuickSort на обсягах до ~10-20 елементів). Стійкий. Працює "онлайн" (може сортувати дані по мірі їх надходження).
 - Недоліки: Повільний на  великих невпорядкованих масивах $O(n^2)$. Велика кількість присвоювань (зсувів масиву).
2. Оцінка методів за критеріями
   Я звів дані у таблицю для наочності:

| Критерій | Bubble Sort | Selection Sort | Insertion Sort |
| :--- | :--- | :--- | :--- |
| **Час (Середній)** | `O(n^2)` | `O(n^2)` | `O(n^2)` |
| **Час (Найкращий)** | `O(n)` | `O(n^2)` | `O(n)` |
| **Пам’ять** | `O(1)` | `O(1)` | `O(1)` |
| **Стійкість** | Стійкий | Нестійкий | Стійкий |

3.Найкращі та найгірші випадки
Найкращий випадок:
- Сценарій: Масив вже відсортований (або майже відсортований).
- Переможець: Insertion Sort (Сортування вставкою). Він просто пройде по масиву один раз, не роблячи зсувів. Час роботи буде лінійним — $O(n)$.
- Примітка: Bubble Sort з прапорцем swapped теж дасть $O(n)$, але Selection Sort завжди буде працювати $O(n^2)$, навіть якщо масив ідеальний.

Найгірший випадок:
- Сценарій: Масив відсортований у зворотному порядку (від найбільшого до найменшого).
- Результат: Усі три алгоритми працюватимуть дуже повільно — $O(n^2)$.
- Анти-лідер: Insertion Sort та Bubble Sort тут найгірші, бо їм доведеться переміщати кожен елемент через увесь масив. Selection Sort працюватиме так само довго за часом порівнянь, але зробить менше записів у пам'ять.

4. Пояснення складності :

1. $O(1)$ - Найшвидший варіант.
Час виконання завжди однаковий і не залежить від кількості даних.
Приклад: Доступ до елемента масиву за індексом.

2. $O(n)$ - Середній варіант.
Час виконання зростає прямо пропорційно кількості даних.
Якщо даних стає вдвічі більше, програма працює вдвічі довше.
Приклад: Пошук числа в несортованому списку.

3. $O(n^2)$ - Повільний варіант.
Час виконання зростає "в квадраті". Це відбувається, коли ми використовуємо вкладені цикли (цикл у циклі).
Якщо даних стає вдвічі більше, програма працює в 4 рази довше.
Приклад: Сортування бульбашкою, сортування вставкою.
